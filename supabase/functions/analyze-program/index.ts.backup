import "jsr:@supabase/functions-js/edge-runtime.d.ts";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, Authorization, X-Client-Info, Apikey",
};

interface AnalysisRequest {
  programmaId: string;
  apiKey: string;
}

Deno.serve(async (req: Request) => {
  if (req.method === "OPTIONS") {
    return new Response(null, {
      status: 200,
      headers: corsHeaders,
    });
  }

  try {
    console.log("Starting analysis...");
    const { programmaId, apiKey }: AnalysisRequest = await req.json();
    console.log("Received programmaId:", programmaId);

    if (!programmaId) {
      throw new Error("programmaId is required");
    }

    if (!apiKey) {
      throw new Error("OpenAI API key is required");
    }

    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const supabaseKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
    console.log("Supabase URL:", supabaseUrl);

    const programmaResponse = await fetch(
      `${supabaseUrl}/rest/v1/programmi_corso?id=eq.${programmaId}&select=*`,
      {
        headers: {
          apikey: supabaseKey,
          Authorization: `Bearer ${supabaseKey}`,
        },
      }
    );

    const programmi = await programmaResponse.json();
    console.log("Found programmi:", programmi);

    if (!programmi || programmi.length === 0) {
      throw new Error("Programma not found");
    }

    const programma = programmi[0];
    console.log("Programma data:", programma);

    if (!programma.classe_laurea_id) {
      throw new Error("Classe di laurea not specified");
    }

    let contenutoProgramma = programma.contenuto_programma;

    if (!contenutoProgramma && programma.pdf_programma_url) {
      throw new Error("Il PDF è stato caricato ma il sistema non può ancora estrarre automaticamente il testo. Per favore, usa la modalità 'Incolla Testo' e copia il contenuto del programma manualmente.");
    }

    if (!contenutoProgramma || contenutoProgramma.trim() === '') {
      throw new Error("Il programma del corso è vuoto. Inserisci il contenuto del programma in modalità testo.");
    }

    const classeLaureaResponse = await fetch(
      `${supabaseUrl}/rest/v1/classi_laurea?id=eq.${programma.classe_laurea_id}`,
      {
        headers: {
          apikey: supabaseKey,
          Authorization: `Bearer ${supabaseKey}`,
        },
      }
    );

    const classiLaurea = await classeLaureaResponse.json();
    if (!classiLaurea || classiLaurea.length === 0) {
      throw new Error("Classe di laurea not found");
    }

    const classeLaurea = classiLaurea[0];
    const classeLaureaFullCode = `${classeLaurea.codice} ${classeLaurea.nome}`;

    const materiaResponse = await fetch(
      `${supabaseUrl}/rest/v1/materie?id=eq.${programma.materia_id}`,
      {
        headers: {
          apikey: supabaseKey,
          Authorization: `Bearer ${supabaseKey}`,
        },
      }
    );

    const materie = await materiaResponse.json();
    const materia = materie[0] || {};

    const matriciResponse = await fetch(
      `${supabaseUrl}/rest/v1/materie_matrici?materia_id=eq.${programma.materia_id}&select=id,nome`,
      {
        headers: {
          apikey: supabaseKey,
          Authorization: `Bearer ${supabaseKey}`,
        },
      }
    );

    const matrici = await matriciResponse.json();

    if (!matrici || matrici.length === 0) {
      throw new Error("No matrix found for this subject");
    }

    const matriceId = matrici[0].id;

    const moduliResponse = await fetch(
      `${supabaseUrl}/rest/v1/materie_moduli?matrice_id=eq.${matriceId}&select=id,nome_modulo,ordine`,
      {
        headers: {
          apikey: supabaseKey,
          Authorization: `Bearer ${supabaseKey}`,
        },
      }
    );

    const moduli = await moduliResponse.json();

    const requisitiPromises = moduli.map(async (modulo: any) => {
      const response = await fetch(
        `${supabaseUrl}/rest/v1/materie_moduli_requisiti?modulo_id=eq.${modulo.id}&classe_laurea_codice=eq.${encodeURIComponent(classeLaureaFullCode)}`,
        {
          headers: {
            apikey: supabaseKey,
            Authorization: `Bearer ${supabaseKey}`,
          },
        }
      );

      const requisiti = await response.json();

      return {
        modulo: modulo.nome_modulo,
        ordine: modulo.ordine,
        requisito: requisiti[0] || null,
      };
    });

    const moduliConRequisiti = await Promise.all(requisitiPromises);

    const moduliValidi = moduliConRequisiti
      .filter((m) => m.requisito !== null)
      .sort((a, b) => a.ordine - b.ordine);

    const requisitiText = moduliValidi
      .map(
        (m) =>
          `- ${m.modulo} (livello ${m.requisito.livello}/10): ${m.requisito.descrizione_contestuale}`
      )
      .join("\n");

    const criteriResponse = await fetch(
      `${supabaseUrl}/rest/v1/criteri_valutazione?materia_id=eq.${programma.materia_id}&select=*`,
      {
        headers: {
          apikey: supabaseKey,
          Authorization: `Bearer ${supabaseKey}`,
        },
      }
    );

    const criteri = await criteriResponse.json();
    const criteriText = criteri
      .sort((a: any, b: any) => a.ordine - b.ordine)
      .map((c: any) => `- ${c.nome} (peso: ${(c.peso * 100).toFixed(0)}%)`)
      .join("\n");

    const manualiZanResponse = await fetch(
      `${supabaseUrl}/rest/v1/manuali?materia_id=eq.${programma.materia_id}&tipo=eq.zanichelli&select=id,titolo,autori,editore,topics_coperti`,
      {
        headers: {
          apikey: supabaseKey,
          Authorization: `Bearer ${supabaseKey}`,
        },
      }
    );

    const manualiZanichelliData = await manualiZanResponse.json();
    const manualiZanichelli = Array.isArray(manualiZanichelliData) ? manualiZanichelliData : [];

    let manualeAttualeDettagli = null;
    if (programma.manuale_attuale) {
      const manualeAttualeResponse = await fetch(
        `${supabaseUrl}/rest/v1/manuali?id=eq.${programma.manuale_attuale}&select=id,titolo,autori,editore,tipo,topics_coperti`,
        {
          headers: {
            apikey: supabaseKey,
            Authorization: `Bearer ${supabaseKey}`,
          },
        }
      );
      const manualeAttualeData = await manualeAttualeResponse.json();
      if (manualeAttualeData && manualeAttualeData.length > 0) {
        manualeAttualeDettagli = manualeAttualeData[0];
      }
    }

    const manualiAlternativiIds = programma.manuali_alternativi || [];
    let manualiAlternativi: any[] = [];

    if (manualiAlternativiIds.length > 0) {
      const manualiAltResponse = await fetch(
        `${supabaseUrl}/rest/v1/manuali?id=in.(${manualiAlternativiIds.join(",")})&select=id,titolo,autori,editore,tipo,topics_coperti`,
        {
          headers: {
            apikey: supabaseKey,
            Authorization: `Bearer ${supabaseKey}`,
          },
        }
      );

      const manualiAlternativiData = await manualiAltResponse.json();
      manualiAlternativi = Array.isArray(manualiAlternativiData) ? manualiAlternativiData : [];
    }

    const manualiZanText = manualiZanichelli
      .map(
        (m: any) =>
          `ID: ${m.id}\nTitolo: ${m.titolo}\nAutori: ${m.autori}\nEditore: ${m.editore}\nArgomenti: ${m.topics_coperti?.join(", ") || "N/A"}`
      )
      .join("\n\n");

    const manualeAttualeText = manualeAttualeDettagli
      ? `ID: ${manualeAttualeDettagli.id}\nTitolo: ${manualeAttualeDettagli.titolo}\nAutori: ${manualeAttualeDettagli.autori}\nEditore: ${manualeAttualeDettagli.editore}\nTipo: ${manualeAttualeDettagli.tipo}\nArgomenti: ${manualeAttualeDettagli.topics_coperti?.join(", ") || "N/A"}`
      : "Non specificato";

    const manualiAltText = manualiAlternativi
      .map(
        (m: any) =>
          `ID: ${m.id}\nTitolo: ${m.titolo}\nAutori: ${m.autori}\nEditore: ${m.editore}\nTipo: ${m.tipo}\nArgomenti: ${m.topics_coperti?.join(", ") || "N/A"}`
      )
      .join("\n\n");

    const istruzioniAI = materia.istruzioni_ai || "";

    const prompt = `Analizza questo programma di ${materia.nome} e valuta i manuali usando la MATRICE DI VALUTAZIONE.\n\n${istruzioniAI ? `ISTRUZIONI SPECIFICHE PER LA MATERIA:\\n${istruzioniAI}\\n\\n` : ""}\n\nCONTESTO:\n- Classe di Laurea: ${classeLaureaFullCode}\n- CFU: ${programma.cfu || "Non specificato"}\n- Ore: ${programma.ore || "Non specificato"}\n- Università: ${programma.universita || "N/A"}\n- Corso di Laurea: ${programma.corso_laurea || "N/A"}\n- Docente: ${programma.docente || "N/A"}\n\nTESTO DEL PROGRAMMA:\n${contenutoProgramma}\n\n═══════════════════════════════════════════════════════════════\nPARTE 1: VALUTAZIONE DEL PROGRAMMA CON LA MATRICE\n═══════════════════════════════════════════════════════════════\n\nMATRICE DI VALUTAZIONE (scala 0-10 per ciascun criterio):\n${criteriText}\n\nCOMPITO - Analisi del Programma:\n\nValuta il PROGRAMMA DEL CORSO (non i manuali!) rispetto a TUTTI i criteri della matrice.\n\nPer OGNI criterio:\n1. Assegna un punteggio 0-10 che valuta quanto il PROGRAMMA risponde a quel criterio:\n   - 0-3: Molto carente, quasi assente\n   - 4-5: Presente ma insufficiente\n   - 6-7: Buono, soddisfa il criterio\n   - 8-9: Ottimo, eccelle sul criterio\n   - 10: Eccellente, stato dell'arte\n\n2. Scrivi note DETTAGLIATE (3-5 righe):\n   - Cosa dice il programma relativamente a questo criterio\n   - Perché hai dato questo punteggio\n   - Esempi concreti tratti dal testo del programma\n   - Cosa potrebbe essere migliorato\n\n3. Calcola punteggio_programma (0-100):\n   Media ponderata usando i pesi: Σ(punteggio × peso) / Σ(pesi) × 10\n\n4. Estrai anche:\n   - Argomenti principali trattati (elenco 5-10 argomenti)\n   - Obiettivi formativi (cosa devono saper fare gli studenti)\n   - Livello di approfondimento (base/intermedio/avanzato)\n\n═══════════════════════════════════════════════════════════════\nPARTE 2: VALUTAZIONE MANUALI CON LA MATRICE\n═══════════════════════════════════════════════════════════════\n\n${manualeAttualeDettagli ? `\nMANUALE ATTUALMENTE IN USO DAL DOCENTE:\nTitolo: ${manualeAttualeDettagli.titolo}\nAutori: ${manualeAttualeDettagli.autori}\nEditore: ${manualeAttualeDettagli.editore}\nID: ${manualeAttualeDettagli.id}\n${manualeAttualeDettagli.topics_coperti?.length > 0 ? `Argomenti trattati: ${manualeAttualeDettagli.topics_coperti.join(", ")}` : ""}\n` : "NESSUN MANUALE ATTUALMENTE SPECIFICATO"}\n\n${manualiAlternativi.length > 0 ? `\nMANUALI ALTERNATIVI SUGGERITI:\n${manualiAlternativi.map(m => `\nTitolo: ${m.titolo}\nAutori: ${m.autori}\nEditore: ${m.editore}\nID: ${m.id}\n${m.topics_coperti?.length > 0 ? `Argomenti: ${m.topics_coperti.join(", ")}` : ""}\n`).join("\\n")}\n` : ""}\n\nCOMPITO - Valutazione Manuali:\n\nValuta SOLO i manuali elencati sopra (attuale + eventuali alternativi).\nNON valutare i manuali Zanichelli in questa sezione.\n\nPer CIASCUN manuale, valutalo con la STESSA matrice usata per il programma:\n\nA) VALUTAZIONE PER CRITERIO:\n   Per OGNI criterio della matrice:\n   - Assegna punteggio 0-10 basato sulla tua conoscenza del manuale\n   - Scrivi note DETTAGLIATE (3-5 righe):\n     * Come il manuale risponde a questo criterio\n     * Perché hai dato questo punteggio\n     * Cosa fa bene, cosa potrebbe migliorare\n     * Esempi concreti quando possibile\n\nB) PUNTEGGIO TOTALE (0-100):\n   Media ponderata: Σ(punteggio × peso) / Σ(pesi) × 10\n\nC) ADEGUATEZZA AL PROGRAMMA (0-100%):\n   Confronta il manuale con IL PROGRAMMA ANALIZZATO:\n   - Quanto copre gli argomenti del programma?\n   - Quanto rispetta il livello di approfondimento richiesto?\n   - 90-100%: perfetta aderenza\n   - 70-89%: buona copertura, qualche integrazione\n   - 50-69%: copertura parziale, integrazioni significative\n   - <50%: inadeguato, molte lacune\n\nD) GAP ANALYSIS (8-12 righe):\n   Confronto dettagliato manuale vs programma:\n   - Argomenti del PROGRAMMA COPERTI dal manuale (elenco)\n   - Argomenti del PROGRAMMA NON COPERTI (gap critici - elenco)\n   - Criteri dove il manuale ECCELLE rispetto al programma\n   - Criteri dove il manuale è CARENTE rispetto al programma\n   - Note generali su adeguatezza e punti di forza/debolezza\n\n═══════════════════════════════════════════════════════════════\nPARTE 3: RACCOMANDAZIONE ZANICHELLI\n═══════════════════════════════════════════════════════════════\n\n${manualiZanichelli.length > 0 ? `\nMANUALI ZANICHELLI DISPONIBILI PER ${materia.nome}:\n\n${manualiZanichelli.map((m, idx) => `\n${idx + 1}. ${m.titolo}\n   Autori: ${m.autori}\n   Editore: ${m.editore}\n   ID: ${m.id}\n   ${m.topics_coperti?.length > 0 ? `Argomenti: ${m.topics_coperti.join(", ")}` : ""}\n`).join("\\n")}\n\nCRITERI DI RACCOMANDAZIONE:\n1. Aderenza agli argomenti del PROGRAMMA analizzato\n2. Punteggio sui criteri della matrice (confronto con manuale attuale)\n3. Adeguatezza al livello del corso (CFU, ore, ambito)\n4. Equilibrio qualità/adeguatezza (troppo completo = svantaggio!)\n\nCOMPITO - Raccomandazione:\n\n1. Esamina TUTTI i manuali Zanichelli disponibili\n2. Per ciascuno valuta mentalmente:\n   - Copertura argomenti del programma\n   - Performance sui criteri della matrice\n   - Adeguatezza al livello (es: 900 pag per 3 CFU è ECCESSIVO)\n   - Confronto con manuale attuale\n\n3. Scegli IL MIGLIORE per questo specifico programma\n\n4. Nel campo \"manuale_raccomandato_id\": ID del manuale scelto\n\n5. Nel campo \"motivazione_raccomandazione\" (400+ parole):\n\n   § PERCHÉ QUESTO ZANICHELLI (100+ parole)\n   - Perché scelto tra i disponibili\n   - Caratteristiche ideali per QUESTO programma\n   - Copertura argomenti (specifici!)\n   - Adeguatezza livello/CFU\n\n   § CONFRONTO CON MANUALE ATTUALE (100+ parole)\n   ${manualeAttualeDettagli ? `\n   - Attuale: ${manualeAttualeDettagli.titolo} (${manualeAttualeDettagli.editore})\n   - Confronto NUMERICO sui criteri della matrice (es: \"Criterio X: Zanichelli 8/10 vs Attuale 6/10\")\n   - Criteri dove Zanichelli è SUPERIORE\n   - Criteri dove attuale potrebbe essere meglio (onestà!)\n   - Motivazioni concrete per il cambio\n   ` : `\n   - Nessun manuale attuale specificato\n   - Perché questo Zanichelli è ideale come riferimento\n   `}\n\n   § COPERTURA PROGRAMMA (100+ parole)\n   - Argomenti coperti PERFETTAMENTE (elenco)\n   - Argomenti che richiedono integrazione (elenco)\n   - Percentuale copertura stimata\n\n   § PUNTI DI FORZA (50+ parole)\n   - Metodologici (esercizi, esempi)\n   - Contenutistici (aggiornamenti)\n   - Didattici (struttura, supporti)\n\n   § INTEGRAZIONI (50+ parole)\n   - Come compensare eventuali gap\n   - Materiali integrativi\n   - Modifiche programma suggerite\n\nREGOLA: Motivazione CONCRETA e COMMERCIALE.\nNon generica (\"ottimo libro\").\nCONVINCERE con NUMERI, CONFRONTI, ELENCHI PRECISI!\n\n` : `\nATTENZIONE: Non ci sono manuali Zanichelli disponibili nel database per questa materia.\n\nImposta:\n- manuale_raccomandato_id: null\n- motivazione_raccomandazione: null\n`}\n\n=======================================\nFORMATO DELLA RISPOSTA\n=======================================\n\nRispondi ESCLUSIVAMENTE con un oggetto JSON valido con questa struttura:\n{\n  \"valutazione_programma\": {\n    \"punteggio_totale\": <0-100, media ponderata>,\n    \"valutazioni_criteri\": [\n      {\n        \"criterio\": \"<nome criterio>\",\n        \"punteggio\": <0-10>,\n        \"note\": \"<3-5 righe: cosa dice il programma su questo criterio>\"\n      }\n    ],\n    \"argomenti_principali\": [\"arg1\", \"arg2\", \"...\"],\n    \"obiettivi_formativi\": \"descrizione\",\n    \"livello\": \"base|intermedio|avanzato\"\n  },\n  \"valutazioni_manuali\": [\n    {\n      \"manuale_id\": \"<ID esatto>\",\n      \"tipo\": \"attuale|alternativo\",\n      \"titolo\": \"<titolo esatto>\",\n      \"punteggio_totale\": <0-100>,\n      \"valutazioni_criteri\": [\n        {\n          \"criterio\": \"<nome>\",\n          \"punteggio\": <0-10>,\n          \"note\": \"<3-5 righe>\"\n        }\n      ],\n      \"adeguatezza_programma\": <0-100>,\n      \"argomenti_coperti\": [\"...\"],\n      \"argomenti_mancanti\": [\"...\"],\n      \"gap_analysis\": \"<8-12 righe: confronto dettagliato con programma>\"\n    }\n  ],\n  \"manuale_raccomandato_id\": \"<ID o null>\",\n  \"motivazione_raccomandazione\": \"<400+ parole o null>\",\n  \"confidence_score\": <0-100>\n}\n\nREGOLE CRITICHE:\n\n1. VALUTAZIONE PROGRAMMA:\n   - Valuta il PROGRAMMA su TUTTI i ${criteri.length} criteri\n   - Punteggio 0-10 per criterio, note 3-5 righe\n   - Punteggio_totale: media ponderata 0-100\n\n2. VALUTAZIONE MANUALI:\n   - Valuta SOLO attuale + alternativi (NON Zanichelli)\n   - STESSA matrice usata per il programma\n   - Per OGNI manuale: tutti i ${criteri.length} criteri\n   - Gap analysis: confronto manuale vs programma\n\n3. RACCOMANDAZIONE:\n   - Zanichelli PIÙ ADATTO (non più completo!)\n   - Motivazione 400+ parole con § paragrafi\n   - Confronti numerici precisi\n   - Elenchi concreti argomenti\n\n4. FORMATO:\n   - SOLO JSON valido\n   - NO markdown, NO commenti\n   - Copia ESATTI titoli e ID`;

    const aiResponse = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${apiKey}`,
      },
      body: JSON.stringify({
        model: "gpt-4o",
        messages: [
          {
            role: "system",
            content: "Sei un esperto consulente editoriale accademico con esperienza nella valutazione di programmi universitari e manuali didattici. Analizza con rigore e precisione. Fornisci valutazioni dettagliate, specifiche e commercialmente utili. Rispondi SEMPRE E SOLO con JSON valido (NO markdown code blocks, NO commenti).",
          },
          {
            role: "user",
            content: prompt,
          },
        ],
        temperature: 0.1,
      }),
    });

    const aiResult = await aiResponse.json();

    if (!aiResponse.ok) {
      throw new Error(`OpenAI API error: ${aiResult.error?.message || 'Unknown error'}`);
    }

    const analysisText = aiResult.choices[0].message.content;

    const jsonMatch = analysisText.match(/\{[\s\S]*\}/);
    const analysis = jsonMatch ? JSON.parse(jsonMatch[0]) : JSON.parse(analysisText);

    await fetch(`${supabaseUrl}/rest/v1/analisi`, {
      method: "POST",
      headers: {
        apikey: supabaseKey,
        Authorization: `Bearer ${supabaseKey}`,
        "Content-Type": "application/json",
        Prefer: "return=minimal",
      },
      body: JSON.stringify({
        programma_corso_id: programmaId,
        valutazione_programma: analysis.valutazione_programma || {},
        valutazioni_manuali: analysis.valutazioni_manuali || [],
        manuale_raccomandato_id: analysis.manuale_raccomandato_id || null,
        motivazione_raccomandazione: analysis.motivazione_raccomandazione || null,
        confidence_score: analysis.confidence_score,
        stato: "completata",
      }),
    });

    return new Response(
      JSON.stringify({
        success: true,
        analysis,
      }),
      {
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json",
        },
      }
    );
  } catch (error) {
    console.error("Error in analyze-program:", error);
    console.error("Error stack:", error instanceof Error ? error.stack : "No stack");

    return new Response(
      JSON.stringify({
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        stack: error instanceof Error ? error.stack : undefined,
      }),
      {
        status: 500,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json",
        },
      }
    );
  }
});